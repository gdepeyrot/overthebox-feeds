#!/bin/sh
# vim: set noexpandtab tabstop=4 shiftwidth=4 softtabstop=4 :

iifs=
for lan in $(uci -q get "firewall.lan.network"); do
	if [ "$(uci -q get "network.$lan.type")" = "bridge" ]; then
		iifs="$iifs br-$lan"
	else
		iifs="$iifs $(uci -q get "network.$lan.device")"
	fi
done

[ -z "$iifs" ] && exit 1

txname="BANDWIDTH-TX"
rxname="BANDWIDTH-RX"

leasefile=$(uci -q get "dhcp.@dnsmasq[0].leasefile")
traf_tmp="/tmp/bandwidth_traf_$$.tmp"
tx_tmp="/tmp/bandwidth_tx_$$.tmp"
rx_tmp="/tmp/bandwidth_rx_$$.tmp"
neigh_tmp="/tmp/bandwidth_neigh.tmp"
awk_fetch="/usr/share/bandwidth/fetch.awk"
awk_watch="/usr/share/bandwidth/watch.awk"
neigh_thresh=7200
interval=5

sig_handler()
{
	rm -f $tx_tmp $rx_tmp $traf_tmp.new $traf_tmp
	exit 0
}

trap 'sig_handler' INT TERM

# This function:
# - fetches neighbor entries along with the last confirmed timer
# - then stores them in a file (format is IP MAC CONFIRMED)
# - installs new nftables rules based on fetched neighbors.
# - cleans up entries if the neigh_thresh has been exceeded.
arp_populate_nftables()
{
	# TODO was > $neigh_tmp before resolving shellcheck SC2188
	# Review if doesn't impact script behaviour
	true > $neigh_tmp
	for iif in $iifs ; do
		ip -s -4 n s dev "$iif" nud reachable nud stale nud delay nud probe nud permanent | {
			while read -r IP _ MAC CONFIRMED; do
				[ -z "$IP" ] && continue
				CONFIRMED=${CONFIRMED#*/}
				CONFIRMED=${CONFIRMED%/*}
				echo "$IP $MAC $CONFIRMED" >> $neigh_tmp
				[ "$CONFIRMED" -gt "$neigh_thresh" ] && continue
				nft list chain ip mangle BANDWIDTH-TX | grep "ip saddr \"$IP\"" | grep "return" 2> /dev/null \
					|| nft add rule ip mangle BANDWIDTH-TX ip saddr "$IP" counter return
				nft list chain ip mangle BANDWIDTH-RX | grep "ip daddr \"$IP\"" | grep "return" 2> /dev/null \
					|| nft add rule ip mangle BANDWIDTH-RX ip daddr "$IP" counter return
			done
		}
	done
}

fetch_bytes()
{
	# Fetches TX/RX by IP
	nft list chain ip mangle $txname > $tx_tmp
	nft list chain ip mangle $rxname > $rx_tmp

	# Replaces IP by MAC, aggregates duplicate MAC into one row (sum of TXs and sum of RXs for that MAC)
	awk -f $awk_fetch \
		-v neighfile="$neigh_tmp" \
		-v leasefile="$leasefile" \
		-v txfile="$tx_tmp" \
		-v rxfile="$rx_tmp" \
		-v json="$1" \
		"$neigh_tmp" "$leasefile" "$tx_tmp" "$rx_tmp"

	rm -f $tx_tmp $rx_tmp
}

# Create mangle table and base chains
nft add table ip mangle
nft add chain ip mangle PREROUTING '{ type filter hook prerouting priority mangle; policy accept;}'
nft add chain ip mangle POSTROUTING '{ type filter hook postrouting priority mangle; policy accept;}'

case $1 in
	# Prepares the chains in PREROUTING and POSTROUTING
	# Populates it with first found devices on the LAN
	"setup")
		nft add chain ip mangle $txname 2> /dev/null
		nft add chain ip mangle $rxname 2> /dev/null
		for iif in $iifs ; do
			nft list chain ip mangle PREROUTING \
				| grep "iifname $iif"| grep "jump $txname" \
				|| nft insert rule ip mangle PREROUTING iifname "$iif" counter jump $txname

			nft list chain ip mangle POSTROUTING \
				| grep "oifname $iif" | grep "jump $rxname" \
				|| nft insert rule ip mangle POSTROUTING oifname "$iif" counter jump $rxname
		done
		arp_populate_nftables
		;;

	# Updates nftables with devices currently found on the LAN
	"ipt-update")
		nft flush chain ip mangle "$txname"
		nft flush chain ip mangle "$rxname"
		arp_populate_nftables
		;;

	# Cleans up everything in nftables
	"unsetup")
		for iif in $iifs ; do
			handle=$(nft -a list chain ip mangle PREROUTING | grep "jump $txname" | cut -d ' ' -f 12)
			nft delete rule ip mangle PREROUTING handle "$handle"

			handle=$(nft -a list chain ip mangle POSTROUTING | grep "jump $rxname" | cut -d ' ' -f 12)
			nft delete rule ip mangle POSTROUTING handle "$handle"
		done
		nft flush chain ip mangle "$txname" 2>/dev/null
		nft flush chain ip mangle "$rxname" 2>/dev/null
		nft delete chain ip mangle "$txname" 2>/dev/null
		nft delete chain ip mangle "$rxname" 2>/dev/null
		rm -f "$neigh_tmp"
		;;

	"fetch")
		if [ "$2" = "json" ]; then
			fetch_bytes "json"
		else
			fetch_bytes
		fi
		;;

	"watch")
		while :
		do
			fetch_bytes > $traf_tmp.new
			clear
			if [ -f $traf_tmp ]; then
				awk -f $awk_watch \
					-v interval="$interval" \
					-v traffile="$traf_tmp" \
					$traf_tmp.new $traf_tmp
			else
				echo "Waiting for data..."
			fi

			mv $traf_tmp.new $traf_tmp
			sleep $interval
		done
		;;

	*)
		echo "Usage: $0 {setup|ipt-update|fetch|watch|unsetup}"
		;;
esac
