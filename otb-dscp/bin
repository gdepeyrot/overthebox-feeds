#!/bin/sh
# vim: set noexpandtab tabstop=4 shiftwidth=4 softtabstop=4 :
# shellcheck disable=SC3043

set -e

# shellcheck disable=SC1091
. /lib/overthebox

# shellcheck disable=SC1091
. /lib/functions.sh

# Get the lan interface name
lan_device=
config_load network
config_get lan_device lan device

# Get the tunnel type
tunnel_type=
config_load glorytun
config_get tunnel_type app mode

config_load dscp

_log() {
	logger -t otb-dscp "$@"
}

_create_mangle_table() {
	# Create chains (PREROUTING, POSTROUTING and OUTPUT), mangle chain was already created by "bandwidth" package
	nft add chain ip mangle PREROUTING '{ type filter hook prerouting priority mangle; policy accept;}'
	nft add chain ip mangle POSTROUTING '{ type filter hook postrouting priority mangle; policy accept;}'
	nft add chain ip mangle OUTPUT '{ type route hook output priority mangle; policy accept;}'
}

_add_dscp_rule() {
	nft add rule ip mangle dscp_prerouting \
		meta l4proto "$proto" ip saddr "$src_ip" \
		ip daddr "$dest_ip" ip dscp set  "$class"\
		comment "\"$comment\""

    nft add rule ip mangle dscp_prerouting \
		meta l4proto "$proto" ip saddr "$src_ip" \
		ip daddr "$dest_ip" \
		return \
		comment "\"$comment\""
}

_add_dscp_rules() {
	proto=""     ; config_get proto "$1" proto all
	src_ip=""    ; config_get src_ip "$1" src_ip 0.0.0.0/0
	src_port=""  ; config_get src_port "$1" src_port 0:65535
	dest_ip=""   ; config_get dest_ip "$1" dest_ip 0.0.0.0/0
	dest_port="" ; config_get dest_port "$1" dest_port 0:65535
	class=""     ; config_get class "$1" class
	direction="" ; config_get direction "$1" direction "upload"
	comment=""   ; config_get comment "$1" comment "-"

	case "$direction" in
		upload)
			# Apply the rule locally
			case "$proto" in
				tcp|udp)
					_add_dscp_rule -m multiport --sports "$src_port" -m multiport --dports "$dest_port"
					;;
				*)
					_add_dscp_rule
					;;
			esac
			;;
		download)
			# Send the route to the remote server
			otb_todo otb_call_api POST "dscp" -d@- <<-EOF
			{
				"proto": "$proto",
				"src_ip": "$src_ip",
				"src_port": "$src_port",
				"dest_ip": "$dest_ip",
				"dest_port": "$dest_port",
				"class": "$class"
			}
			EOF
			;;
	esac
}

_add_prerouting_chain() {
	nft add chain ip mangle dscp_prerouting
	nft insert rule ip mangle PREROUTING iifname "$lan_device" counter jump "$1"
}

_add_fwmark_chain() {
	nft add chain ip mangle dscp_mark
	nft add rule ip mangle PREROUTING iifname "$lan_device" counter jump dscp_mark
	for class in cs4 cs5 cs6 cs7; do
		# xtun (hex) -> 0x7874756e
		nft add rule mangle dscp_mark \
			ip dscp "$class" \
			ct mark 0x7874756e \
			comment "$class"
	done
}

_add_dscp_output_chain() {
	nft add chain ip mangle dscp_output
	nft add rule ip mangle OUTPUT counter jump dscp_output
}

_remove_prerouting_chain() {
	local subchain_handle

	# Delete rules one by one inside subchain
	nft flush chain ip mangle "$1" 2>/dev/null || return 0

	# Remove rule from prerouting that allow to jump to subchain
	subchain_handle=""
	subchain_handle=$(nft -a list table ip mangle | grep "jump $1" | cut -d ' ' -f 12)
	nft delete rule ip mangle  PREROUTING handle "$subchain_handle"

	# Remove subchain
	subchain_handle=""
	subchain_handle=$(nft -a list table ip mangle | grep "chain $1" | cut -d ' ' -f 6)
	nft delete chain ip mangle handle "$subchain_handle"
}

_remove_output_chain() {
	local subchain_handle

	# Delete rules one by one inside subchain
	nft flush chain ip mangle "$1" 2>/dev/null || return 0

	# Remove rule from prerouting that allow to jump to subchain
	subchain_handle=""
	subchain_handle=$(nft -a list table ip mangle | grep "jump $1" | cut -d ' ' -f 10)
	nft delete rule ip mangle OUTPUT handle "$subchain_handle"

	# Remove subchain
	subchain_handle=""
	subchain_handle=$(nft -a list table ip mangle | grep "chain $1" | cut -d ' ' -f 6)
	nft delete chain ip mangle handle "$subchain_handle"
}

_setup_tunnel() {
	case "$tunnel_type" in
		glorytun)
			# Mark the packets to route through xtun0
			_add_fwmark_chain
			# tun0: cs0 (default)
			# xtun0: cs6
			nft add rule ip mangle dscp_output oifname "xtun0" dscp set cs6
			;;
		glorytun_hybrid)
			# Mark the packets to route through xtun0
			_add_fwmark_chain
			# tun0: cs0 (default)
			# xtun0: mud handles the dscp by itself
			;;
		glorytun_mud)
			# tun0: mud handles the dscp by itself
			;;
	esac
}

_stop() {
	_remove_prerouting_chain dscp_prerouting
	_remove_prerouting_chain dscp_mark
	_remove_output_chain dscp_output

	otb_todo otb_call_api DELETE "dscp" </dev/null
}

_start() {
	# Add table and chains
	_create_mangle_table
	_add_prerouting_chain dscp_prerouting
	_add_dscp_output_chain

	# Setup the tunnels dscp / marks
	_setup_tunnel

	# Add rules base on the user configuration
	config_foreach _add_dscp_rules classify
}

dscp_count=0

_check() {
	configured_count=$(otb_call_api GET qos | jq '.dscp | length')
	dscp_count=0
	config_foreach _count_remote_dscp classify
	[ "$configured_count" = "$dscp_count" ] && return 0

	_log "$dscp_count DSCP rules are configured but only $configured_count are applied. Need to restart"
	_stop
	_start
}

_count_remote_dscp() {
	direction=
	config_get direction "$1" direction
	[ "$direction" = download ] || return 0

	dscp_count=$((dscp_count+1))
}

case "$1" in
	start)
		_log "Starting"
		_start
		;;
	stop)
		_stop
		;;
	check)
		_check
		;;
	*) exit 1 ;;
esac
